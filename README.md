# OpenSCAD Tree-sitter Grammar

A Tree-sitter grammar for the OpenSCAD language, providing parsing capabilities for Node.js applications. This project enables syntax highlighting, code navigation, and incremental parsing for OpenSCAD files.

## Project Structure

This project follows the recommended Tree-sitter project organization with a focus on Node.js bindings:

```
openscad-tree-sitter/
├── bindings/            # Language bindings
│   ├── node/            # Node.js bindings (active)
│   │   ├── binding.cc   # C++ binding code for Node.js
│   │   ├── index.js     # JavaScript interface
│   │   └── index.d.ts   # TypeScript type definitions
│   └── wasm/            # WebAssembly bindings
│       ├── tree-sitter-openscad.wasm  # Compiled WASM module
│       └── README.md    # WASM usage documentation
├── examples/            # Example OpenSCAD files
│   ├── control-structures.scad  # Examples of control structures
│   ├── indentation-test.scad    # Examples for testing indentation
│   ├── object-literals.scad     # Examples of object literals
│   ├── sample.scad              # Basic sample code
│   └── real-world/              # Real-world examples
│       ├── architectural_model.scad  # Architectural model example
│       ├── mathematical_surfaces.scad # Mathematical surfaces
│       └── mechanical_gearbox.scad    # Mechanical parts
├── grammar.js           # The grammar definition (main source file)
├── queries/             # Tree-sitter queries
│   ├── highlights.scm   # Syntax highlighting rules
│   ├── folds.scm        # Code folding rules
│   ├── indents.scm      # Indentation rules
│   ├── injections.scm   # Language injection rules
│   ├── locals.scm       # Local variable tracking
│   └── tags.scm         # Code navigation tags
├── src/                 # Generated parser code (created by build)
│   ├── parser.c         # Generated C parser
│   ├── grammar.json     # Generated grammar specification
│   ├── node-types.json  # Node type definitions
│   ├── tree_sitter/     # Tree-sitter headers
│   └── web/             # Web-specific code
│       └── openscad-wasm.js  # JavaScript for WASM integration
├── test/                # Test files
│   ├── assets/          # Test assets
│   │   └── all-features-openscad.scad  # Comprehensive test file
│   ├── benchmark/       # Performance benchmark files
│   ├── corpus/          # Test corpus for grammar validation
│   ├── nodejs/          # Node.js specific tests
│   └── browser/         # Browser-specific tests
```

## Key Files and Their Purposes

### Core Files

- **grammar.js**: The heart of the project, containing the grammar definition for the OpenSCAD language. This file defines all syntax rules, operator precedence, and language constructs.

- **package.json**: Project configuration, dependencies, and scripts for building, testing, and running the parser.

- **tree-sitter.json**: Configuration for tree-sitter CLI, specifying which language bindings to generate (currently only Node.js).

### Generated Files

These files are automatically generated by the build process and should not be edited manually:

- **src/parser.c**: The C implementation of the parser, generated from grammar.js.
- **src/grammar.json**: JSON representation of the grammar rules.
- **src/node-types.json**: Definitions of syntax tree node types.
- **bindings/wasm/tree-sitter-openscad.wasm**: WebAssembly binary for browser usage.

### Queries

Queries define how editors and tools interact with the parsed syntax tree:

- **queries/highlights.scm**: Rules for syntax highlighting in editors.
- **queries/folds.scm**: Rules for code folding (collapsing blocks of code).
- **queries/indents.scm**: Rules for automatic indentation.
- **queries/locals.scm**: Rules for tracking local variables and their scopes.
- **queries/tags.scm**: Rules for code navigation (jumping to definitions).

### Node.js Bindings

- **bindings/node/index.js**: JavaScript interface for using the parser in Node.js.
- **bindings/node/index.d.ts**: TypeScript type definitions.
- **bindings/node/binding.cc**: C++ code that connects the parser to Node.js.

### WebAssembly Support

- **bindings/wasm/tree-sitter-openscad.wasm**: Compiled WebAssembly module.
- **src/web/openscad-wasm.js**: JavaScript code for loading and using the WASM module.

### Tests

- **test/corpus/**: Test files that verify the grammar's correctness.
- **test/nodejs/**: Tests for the Node.js bindings.
- **test/assets/all-features-openscad.scad**: A comprehensive test file covering all OpenSCAD features.

## Installation

```bash
npm install openscad-tree-sitter
# or
pnpm add openscad-tree-sitter
# or
yarn add openscad-tree-sitter
```

## Usage with Node.js

```javascript
const Parser = require('openscad-tree-sitter');

// Parse OpenSCAD code
const code = `cylinder(h=10, r=5);`;
const tree = Parser.parse(code);

// Access the parsed syntax tree
console.log(tree.rootNode.toString());
```

## Usage with TypeScript

```typescript
import { Parser } from 'openscad-tree-sitter';

// Parse OpenSCAD code
const code = `cylinder(h=10, r=5);`;
const tree = Parser.parse(code);

// Access the parsed syntax tree
console.log(tree.rootNode.toString());
```

## Development

### Prerequisites

- Node.js 16+ (recommended: Node.js 18 or newer)
- pnpm (recommended) or npm
- Git

### Building the Project

```bash
# Clone the repository
git clone https://github.com/yourusername/openscad-tree-sitter.git
cd openscad-tree-sitter

# Install dependencies
pnpm install

# Generate the parser
pnpm build

# Run tests
pnpm test
```

### Build Process Explained

The build process consists of several steps:

1. **Grammar Generation**: `pnpm build` runs `tree-sitter generate`, which:
   - Processes `grammar.js` to create the parser implementation
   - Generates `src/parser.c`, `src/grammar.json`, and `src/node-types.json`
   - Creates language binding code in `bindings/node/binding.cc`

2. **WebAssembly Build**: `pnpm build:wasm` runs `tree-sitter build --wasm`, which:
   - Compiles the parser to WebAssembly
   - Outputs to `bindings/wasm/tree-sitter-openscad.wasm`
   - Enables browser-based parsing

3. **Complete Build**: `pnpm build:all` runs both steps above

### Development Workflow

1. **Edit Grammar**: Modify `grammar.js` to update language rules
2. **Build**: Run `pnpm build` to generate updated parser code
3. **Test**: Run `pnpm test` to verify changes
4. **Parse Examples**: Run `pnpm parse:examples` to test with real-world examples
5. **Playground**: Run `pnpm playground` to interactively test the grammar

### Debugging the Grammar

When encountering parsing issues:

1. Use `pnpm parse <file.scad>` to see how a specific file is parsed
2. Check the parse tree for unexpected structures
3. Run `pnpm test:wasm` to verify WebAssembly compatibility
4. Use the playground (`pnpm playground`) for interactive debugging

## Testing

The project includes comprehensive tests to ensure the grammar correctly parses OpenSCAD code.

### Test Organization

- **test/corpus/**: Contains test files that validate specific grammar features
- **test/nodejs/**: Contains tests for the Node.js bindings
- **test/assets/**: Contains sample OpenSCAD files for testing
- **test/benchmark/**: Contains files for performance testing

### Available Test Commands

```bash
# Run all tests
pnpm test

# Run specific test categories
pnpm test:all        # Run all test suites
pnpm test:wasm       # Test WebAssembly build
pnpm test:parsing    # Test parsing functionality
pnpm test:native     # Test native Node.js bindings
pnpm test:examples   # Test with example files

# Run browser tests
pnpm test:browser    # Test in browser environment
```

### What the Tests Verify

The test suite checks various aspects of the grammar, including:

- **Basic Syntax**: Comments, variable assignments, modules, functions
- **Control Structures**: If statements, for loops, conditionals
- **Expressions**: Mathematical operations, function calls, array access
- **Advanced Features**: List comprehensions, special variables, object literals
- **Edge Cases**: Error recovery, ambiguous syntax, precedence rules

### Adding New Tests

To add new tests:

1. For corpus tests, add a new section to an existing file in `test/corpus/` or create a new file
2. For specific feature tests, add test cases to the appropriate test file in `test/nodejs/`
3. For real-world examples, add OpenSCAD files to `examples/real-world/`

## Improved Grammar Features

This grammar supports the full OpenSCAD language specification with additional improvements:

### Core Features
- Module definitions and instantiations
- Function definitions and calls
- Mathematical expressions
- Conditional statements
- For loops
- Include/use directives
- Variables and assignments

### Advanced Features
- List comprehensions with conditions
- Special variables ($fa, $fs, $fn, etc.)
- Multi-dimensional arrays
- Array slicing with range expressions
- Object literals for structured data
- Let expressions for local variable definitions
- Member access expressions
- Improved type handling (numbers, strings, booleans, undef)

## Grammar Design

### Parser Architecture

The OpenSCAD grammar is designed as an LR(1) grammar with careful attention to operator precedence and ambiguity resolution. Key design principles include:

- **Precedence Hierarchy**: Expressions follow a clear precedence order from conditional expressions (lowest) to unary expressions (highest)
- **Error Recovery**: The grammar includes robust error recovery mechanisms to handle common syntax errors
- **Conflict Resolution**: Ambiguities are resolved using precedence annotations and the conflicts array

### Handling Ambiguities

The grammar resolves several types of ambiguities:

- **Shift/Reduce Conflicts**: Resolved using precedence annotations (`prec`, `prec.left`, `prec.right`)
- **Reduce/Reduce Conflicts**: Handled through the `conflicts` array for intentional ambiguities
- **Expression vs. Statement**: Carefully separated to avoid confusion between expressions and statements

### Precedence Levels

The grammar uses the following precedence levels (higher number = higher precedence):

1. Conditional expressions (`?:`)
2. Logical OR (`||`)
3. Logical AND (`&&`)
4. Equality operators (`==`, `!=`)
5. Relational operators (`<`, `<=`, `>`, `>=`)
6. Additive operators (`+`, `-`)
7. Multiplicative operators (`*`, `/`, `%`)
8. Exponentiation (`^`)
9. Unary operators (`!`, `-`)
10. Modifiers (`#`, `!`, `%`, `*`)

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Contribution Guidelines

- Follow the existing code style and organization
- Add tests for new features or bug fixes
- Update documentation to reflect changes
- Ensure all tests pass before submitting a PR
- Keep PRs focused on a single change to simplify review

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Tree-sitter team for the amazing parser generator
- OpenSCAD developers for the language specification
- Contributors who have helped improve the grammar