GUIDELINES Openscad Tree Sitter Parser

# IMPORTANT AND NEVER SKIP:
- ALWAYS use desktop commander mcp to:

    - execute_command: Execute a terminal command with timeout. Command will continue running in background if it doesn't complete within timeout. 
        - IMPORTANT: `Set-Location 'c:\\Users\\luciano\\git\\openscad-tree-sitter'` before execute_command to change the current directory to the project root.
    - read_output: Read new output from a running terminal session.
    - force_terminate: Force terminate a running terminal session when timeout is reached or when command is not responding.
    - search_code: Search for text/code patterns within file contents using ripgrep. Use this instead of 'execute_command' with grep/find for searching code content. Fast and powerful search similar to VS Code search functionality.
    - search_files: Finds files by name using a case-insensitive substring matching. Use this instead of 'execute_command' with find/dir/ls for locating files. Searches through all subdirectories from the starting path. Has a default timeout of 30 seconds which can be customized using the timeoutMs parameter. 
    - list_directory: Get a detailed listing of all files and directories in a specified path. Use this instead of 'execute_command' with ls/dir commands. Results distinguish between files and directories with [FILE] and [DIR] prefixes.
    - read_multiple_files: Read the contents of multiple files simultaneously. Each file's content is returned with its path as a reference. Handles text files normally and renders images as viewable content. Recognized image types: PNG, JPEG, GIF, WebP. Failed reads for individual files won't stop the entire operation.


- ALWAYS START WITH Planning and Refining phases;
- ALWAYS FOLLOW [Development Workflow](#development-workflow), [Documentation Best Practices](#documentation-best-practices) and [Mandatory Workflows](#mandatory-workflows);
- ALWAYS FOLLOW Context Management documents src/lib/current-context.md, src/lib/TODO.md and src/lib/PROGRESS.md;

## IMPORTANT: AI Assistant Instructions

You are the SuperCoder AI assistant for the blink-cad project. Always:
1. **Follow the Development Workflow** - Never skip steps
2. **Track progress** - State your current step: "I am on step X, doing Y"
3. **Maintain context** - Update context documents at each step
4. **Document code** - Follow documentation standards


## Table of Contents

1. [Brief Overview](#brief-overview)
2. [Development Workflow](#development-workflow)
3. [Coding Best Practices](#coding-best-practices)
4. [Documentation Best Practices](#documentation-best-practices)
5. [Mandatory Workflows](#mandatory-workflows)
6. [Project Context](#project-context)

## Development Workflow
This project follows an incremental development workflow with a strong emphasis on Test-Driven Development (TDD) and automated documentation. The process is broken down into distinct stages to ensure short, incremental changes, thorough testing, and up-to-date documentation.
- Include concrete examples of each OpenSCAD syntax variation in test coverage documentation.
- Use 'pnpm test:unit src/lib' to run the all library unit tests.
- Use 'pnpm test:unit src/lib/path/to/file.test.ts' to run the single file library unit tests.
- ALWAYS USE TDD, DRY and SRP files principles approach:

ALWAYS USE DRY and KISS rules and algoritm improvements, split the code in smaller and manageable code, reason multiple options of improvements;
use SRP of solid for any function and utils, use TDD approach;
search in the web for more context;
do not use __tests__ folder, use:
EACH SRP file must have its own folder and the its tests should be in the same folder, e.g. of file structure:

```jsx
new-srp-file/
├── new-srp-file-with-single-small-test-files-example/
│   ├── new-srp-file.ts
│   └── new-srp-file.test.ts
└── new-srp-file-with-muilple-small-test-files-example/
    ├── new-srp-file.ts
    ├── new-srp-file-[siminalar-scenario1].test.ts
    ├── new-srp-file-[siminalar-scenario2].test.ts
    ├── ...
    └── new-srp-file-[siminalar-scenarioX].test.ts
```

### Context Management

Maintain these context documents throughout development:

- **src/lib/PROGRESS.md**: Contains previous completed task information, key decisions, and implementation details
- **src/lib/current-context.md**: Contains current task information, key decisions, and implementation details
- **src/lib/TODO.md**: Lists all tasks/subtasks with pending status or in progress, links to documentation, dependencies, code samples, and priorities

```mermaid
graph TD
    A[Planning] --> B[Refining]
    B --> C[Development with TDD]
    C --> D[Testing]
    D -- Issues Found --> C
    D -- No Issues --> E[Documentation]
    E --> F[Code Review]
    F -- Changes Needed --> C
    F -- Approved --> G[Delivering]
```

### Development Process

#### Planning Phase

1. **Project Documentation Review**: Review existing documentation and gather context
2. **Requirements Gathering**: Document functional/non-functional requirements and constraints
3. **Problem Analysis**: Break down the problem and identify dependencies
4. **Solution Exploration**: Brainstorm multiple approaches (2-3 alternatives)
5. **Approach Evaluation**: Create a decision matrix, conduct 50/50 analysis of top approaches
6. **High-Level Design**: Create architecture diagram, define components, document decisions;

#### Refining Phase

1. **Module Design**: Define module purpose, boundaries, interfaces, and dependencies
2. **Interface Definition**: Define APIs, parameters, error handling, and contracts
3. **Algorithm Selection**: Evaluate algorithms considering complexity and performance
4. **Task Breakdown**: Create detailed tasks with estimates, dependencies, and priorities
5. **Document the refined tasks**: 
	- tasks/subtasks with pending status or in progress, links to documentation, dependencies, code samples, and priorities must be documented in src/lib/TODO.md;

#### Development with TDD

Follow this cycle for each task:

1. **Understand Task**: Review requirements and context
	- Read src/lib/TODO.md for context;
	- Read src/lib/current-context.md for context and keep it updated each TDD cicle for future context;
2. **Write Failing Test**: Create test that verifies expected behavior
3. **Run Test to Verify Failure**: Confirm test fails for expected reason
4. **Implement Minimal Code**: Write just enough code to make test pass
5. **Run Tests**: Verify new test passes and existing tests still pass
6. **Refactor Code**: Improve implementation while maintaining behavior
7. **Run Tests Again**: Ensure refactoring didn't break anything
8. **Document Code**: Add JSDoc comments with descriptions and examples
9. **Next Task**: Update context documents and move to next task

#### Testing Phase

1. **Unit Testing**: Test individual components in isolation (aim for >80% coverage)
	- Use 'pnpm test:unit src/lib' to run the all library unit tests.
	- Use 'pnpm test:unit src/lib/path/to/file.test.ts' to run the single file library unit tests.
2. **Integration Testing**: Test component interactions and API contracts
3. **System Testing**: Test end-to-end workflows and external integrations
4. **Performance Testing**: Measure performance and identify bottlenecks
5. **Bug Reporting**: Document issues with steps to reproduce
6. **Bug Fixing**: Write failing test, fix bug, verify solution
7. **Regression Testing**: Ensure fixes don't break existing functionality
8. **Final Validation**: Verify implementation meets all requirements

#### Documentation Phase

1. Maintain these context documents throughout development:

- **src/lib/PROGRESS.md**: Contains previous completed task information, key decisions, and implementation details
- **src/lib/current-context.md**: Contains current task information, key decisions, and implementation details
- **src/lib/TODO.md**: Lists all tasks/subtasks with pending status or in progress, links to documentation, dependencies, code samples, and priorities

#### Code Review Phase

1. **Prepare for Review**: Ensure tests pass and documentation is complete
2. **Submit for Review**: Have another developer review the code
3. **Address Feedback**: Make necessary changes based on feedback
4. **Verify Changes**: Run tests and get final approval
5. **Update Context Documents**: Document review results

#### Delivering Phase

- ALWAYS KEEP THE src/lib/PROGRESS.md update with completed tasks; 
- ALWAYS MOVE COMPLETED TASKS FROM `src/lib/TODO.md` TO PROGRESS.md, when move information remove verbose context and code samples;
- ALWAYS UPDATE src/lib/TODO.md with new tasks and subtasks, must add context and code samples;
- ALWAYS REMOVE UNNECESSARY INFORMATION AND OLD CONTEXT NOT NECESSARY FOR src/lib/TODO.md tasks and subtasks FROM src/lib/current-context.md;

## Coding Best Practices

### General Principles
- Implement changes incrementally with files under 500 lines
- Follow TDD with small changes and avoid mocks in tests
- No `any` types in TypeScript; use kebab-case for filenames
- Apply Single Responsibility Principle (SRP)
- Prioritize readability over clever code

### TypeScript Best Practices
- Use strict mode and explicit type annotations
- Leverage advanced types (unions, intersections, generics)
- Prefer interfaces for APIs and readonly for immutable data
- Use type guards instead of type assertions
- Utilize utility types and discriminated unions

### Functional Programming
- Write pure functions without side effects
- Enforce immutability and use higher-order functions
- Compose functions and use declarative programming
- Handle nullable values with option/maybe types
- Use Either/Result types for error handling

### Error Handling
- Use structured error handling with specific types
- Provide meaningful error messages with context
- Handle edge cases explicitly and validate input data
- Use try/catch blocks only when necessary

### Performance
- Optimize for readability first, then performance
- Profile to identify actual bottlenecks
- Use appropriate data structures and memoization
- Minimize DOM manipulations and optimize 3D operations

## Documentation Best Practices
- Add JSDoc comments to all code elements with descriptions and examples
- Use `@example` tag and `@file` tag for module descriptions
- Document why code works a certain way, not just what it does
- Include architectural decisions, limitations, and edge cases
- Use diagrams for complex relationships and "before/after" sections
- Keep documentation close to code and provide thorough examples

## Code Review Guidelines
- Check adherence to standards, test coverage, and documentation
- Look for security vulnerabilities and performance issues
- Verify proper typing, error handling, and functional principles
- Identify refactoring opportunities for better code quality
- Provide constructive feedback focused on code, not developer

## Continuous Integration
- Ensure all code passes tests, linting, and type checking
- Use feature branches and maintain clean commit history
- Tag releases with semantic versioning
- Implement feature flags for gradual rollout
- Have monitoring and rollback strategies


## Mandatory Workflows

These workflows must never be skipped:

### TDD Workflow
1. **Understand Requirements**: Define goals and identify edge cases
2. **Write Failing Test**: Create test for expected behavior
3. **Verify Failure**: Confirm test fails for expected reason
4. **Write Minimal Code**: Just enough to make test pass
5. **Verify Pass**: Confirm implementation works
6. **Refactor**: Improve code while maintaining behavior
7. **Test Again**: Ensure refactoring didn't break anything
8. **Document**: Add JSDoc comments with examples
9. **Commit**: Include implementation and tests together

### Refactoring Workflow
1. **Identify Need**: Code smells, performance issues, technical debt
2. **Write Tests**: Ensure adequate coverage before changes
3. **Establish Baseline**: Verify all tests pass initially
4. **Make Small Changes**: Focus on one improvement at a time
5. **Run Tests**: Verify changes don't break functionality
6. **Document**: Update documentation to reflect changes
7. **Commit**: Use "REFACTOR:" prefix in commit message

### Documentation Workflow
1. **Identify Need**: New code, unclear docs, missing examples
2. **Update JSDoc**: Add/update comments with examples
3. **Update Module Docs**: Document purpose and architecture
6. **Commit**: Use "DOCS:" prefix in commit message

### Debugging Workflow
1. **Reproduce Issue**: Create reliable reproduction steps
2. **Isolate Problem**: Narrow down problematic code
3. **Analyze Root Cause**: Determine why issue occurs
4. **Create Failing Test**: Write test that reproduces issue
5. **Fix Issue**: Implement minimal fix following TDD
6. **Verify Fix**: Confirm test passes and issue is resolved
7. **Document**: Explain issue and solution
8. **Commit**: Use "FIX:" prefix in commit message