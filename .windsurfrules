# GUIDELINES: OpenSCAD Tree-Sitter Parser Monorepo

## IMPORTANT AND NEVER SKIP:
- ALWAYS use desktop commander mcp to:

    - mcp2_execute_command: Execute a terminal command with timeout. Command will continue running in background if it doesn't complete within timeout.
        - IMPORTANT: Always use absolute paths (starting with 'c:\\' or '/')
        - Example: `mcp2_execute_command { "command": "pnpm test", "cwd": "c:\\Users\\luciano\\git\\openscad-tree-sitter" }`
    - mcp2_read_file: Read file contents. Always use absolute paths.
    - mcp2_write_file: Write to files. Always use absolute paths.
    - mcp2_search_code: Search for text/code patterns within file contents using ripgrep.
    - mcp2_search_files: Find files by name using case-insensitive matching.
    - mcp2_list_directory: Get detailed directory listings with [FILE] and [DIR] prefixes.
    - mcp2_edit_block: Make precise file edits with context awareness.
    - mcp2_read_multiple_files: Read multiple files simultaneously.


- ALWAYS START WITH Planning and Refining phases;
- ALWAYS FOLLOW [Development Workflow](#development-workflow), [Documentation Best Practices](#documentation-best-practices) and [Mandatory Workflows](#mandatory-workflows);
- ALWAYS FOLLOW Context Management documents docs/current-context.md, docs/TODO.md and docs/PROGRESS.md;

## IMPORTANT: AI Assistant Instructions

You are the SuperCoder AI assistant for the blink-cad project. Always:
1. **Follow the Development Workflow** - Never skip steps
2. **Track progress** - State your current step: "I am on step X, doing Y"
3. **Maintain context** - Update context documents at each step
4. **Document code** - Follow documentation standards


## Table of Contents

1. [Brief Overview](#brief-overview)
2. [Development Workflow](#development-workflow)
3. [Nx Monorepo Structure](#nx-monorepo-structure)
4. [Testing Guidelines](#testing-guidelines)
5. [Script Commands](#script-commands)
6. [Coding Best Practices](#coding-best-practices)
7. [Documentation Best Practices](#documentation-best-practices)
8. [Mandatory Workflows](#mandatory-workflows)
9. [Project Context](#project-context)
10. [Development Setup](#development-setup)
11. [Debugging Guide](#debugging-guide)

## Brief Overview

This project is an Nx monorepo with PNPM workspaces containing packages for parsing and working with OpenSCAD files using Tree-sitter. The repository consists of two main packages:

- **packages/tree-sitter-openscad**: Tree-sitter grammar for OpenSCAD
- **packages/openscad-parser**: TypeScript parser for OpenSCAD using the tree-sitter grammar

## Development Workflow

This project follows an incremental development workflow with a strong emphasis on Test-Driven Development (TDD) and automated documentation. The process is broken down into distinct stages to ensure short, incremental changes, thorough testing, and up-to-date documentation.

- Include concrete examples of each OpenSCAD syntax variation in test coverage documentation.
- Use `pnpm test` to run all tests across the monorepo.
- Use `pnpm test:grammar` or `pnpm test:parser` to run tests for specific packages.
- Use `nx test tree-sitter-openscad` or `nx test openscad-parser` for more granular control.
- ALWAYS USE TDD, DRY and SRP files principles approach:

ALWAYS USE DRY and KISS rules and algoritm improvements, split the code in smaller and manageable code, reason multiple options of improvements;
use SRP of solid for any function and utils, use TDD approach;
search in the web for more context;
do not use __tests__ folder, use:
EACH SRP file must have its own folder and the its tests should be in the same folder, e.g. of file structure:

```jsx
new-srp-file/
├── new-srp-file-with-single-small-test-files-example/
│   ├── new-srp-file.ts
│   └── new-srp-file.test.ts
└── new-srp-file-with-muilple-small-test-files-example/
    ├── new-srp-file.ts
    ├── new-srp-file-[siminalar-scenario1].test.ts
    ├── new-srp-file-[siminalar-scenario2].test.ts
    ├── ...
    └── new-srp-file-[siminalar-scenarioX].test.ts
```

### Development Process

#### Planning Phase

1. **Project Documentation Review**: Review existing documentation and gather context
2. **Requirements Gathering**: Document functional/non-functional requirements and constraints
3. **Problem Analysis**: Break down the problem and identify dependencies
4. **Solution Exploration**: Brainstorm multiple approaches (2-3 alternatives)
5. **Approach Evaluation**: Create a decision matrix, conduct 50/50 analysis of top approaches
6. **High-Level Design**: Create architecture diagram, define components, document decisions

#### Refining Phase

1. **Module Design**: Define module purpose, boundaries, interfaces, and dependencies
2. **Test Strategy**: Plan test cases to cover normal behavior, edge cases, and error scenarios
3. **Acceptance Criteria**: Define clear criteria for when the feature is complete
4. **Task Breakdown**: Create small, manageable tasks (1-2 hours each)
5. **Prioritization**: Sort tasks by dependencies and impact

#### Development with TDD Phase

1. **Write Test First**: Create failing test for a specific feature
2. **Implement Feature**: Write minimal code to make the test pass
3. **Refactor**: Improve code quality while keeping tests green
4. **Repeat**: Continue with next feature

#### Testing Phase

1. **Unit Tests**: Verify individual components
2. **Integration Tests**: Test component interactions
3. **Performance Tests**: Check performance metrics (if applicable)
4. **Edge Case Testing**: Validate behavior in extreme conditions
5. **Error Handling**: Verify graceful handling of invalid inputs

#### Documentation Phase

1. **Code Comments**: Update JSDoc for public API
2. **Update README**: Update usage examples and FAQs
3. **Architecture Documentation**: Update design diagrams
4. **Release Notes**: Document changes, additions, and deprecations

## Nx Monorepo Structure

This project is structured as an Nx monorepo with PNPM workspaces. The key configuration files are:

- **nx.json**: Defines task dependencies and Nx configuration
- **package.json**: Root package with scripts for the entire monorepo
- **pnpm-workspace.yaml**: Defines the PNPM workspace structure
- **packages/*/project.json**: Project-specific configuration for Nx

### Project Organization

```
openscad-tree-sitter/
├── packages/
│   ├── tree-sitter-openscad/   # Tree-sitter grammar package
│   │   ├── bindings/           # Language bindings
│   │   ├── examples/           # Example OpenSCAD files
│   │   ├── grammar.js          # The grammar definition
│   │   ├── queries/            # Tree-sitter queries
│   │   ├── src/                # Source code
│   │   ├── test/               # Tests for the grammar
│   │   └── project.json        # Nx project configuration
│   │
│   └── openscad-parser/        # TypeScript parser package
│       ├── src/                # Source code
│       │   └── lib/            # Library code
│       ├── test/               # Tests for the parser
│       └── project.json        # Nx project configuration
│
├── nx.json                     # Nx configuration
└── pnpm-workspace.yaml         # PNPM workspace configuration
```

### Context Management

Maintain these context documents throughout development:

- **docs/PROGRESS.md**: Contains previous completed task information, key decisions, and implementation details
- **docs/current-context.md**: Contains current task information, key decisions, and implementation details
- **docs/TODO.md**: Lists all tasks/subtasks with pending status or in progress, links to documentation, dependencies, code samples, and priorities

```mermaid
graph TD
    A[Planning] --> B[Refining]
    B --> C[Development with TDD]
    C --> D[Testing]
    D -- Issues Found --> C
    D -- No Issues --> E[Documentation]
    E --> F[Code Review]
    F -- Changes Needed --> C
    F -- Approved --> G[Delivering]
```

## Testing Guidelines

### Testing Philosophy

- **Test-Driven Development**: Write tests before implementation code
- **Comprehensive Coverage**: Aim for high test coverage of all functionality
- **Integration Testing**: Ensure components work together correctly
- **Maintainable Tests**: Keep tests readable and maintainable

### Testing Best Practices

1. **Real Parser Instance**: Do not use mocks for OpenscadParser in tests
```typescript
describe("OpenSCADParser", () => {
  let parser: OpenscadParser;

  beforeEach(async () => {
    // Create a new parser instance before each test
    parser = new OpenscadParser();

    // Initialize the parser
    await parser.init();
  });

  afterEach(() => {
    // Clean up after each test
    parser.dispose();
  });
});
```

2. **Test Organization**: Group tests logically by functionality
3. **Descriptive Test Names**: Use clear and descriptive test names
4. **Isolated Tests**: Each test should be independent and not rely on state from other tests
5. **Test Error Cases**: Include tests for error handling and edge cases

## Script Commands

### Root Package Scripts

- **Build Commands**:
  - `pnpm build`: Build all packages
  - `pnpm build:grammar`: Build only the tree-sitter-openscad package
  - `pnpm build:parser`: Build only the openscad-parser package

- **Test Commands**:
  - `pnpm test`: Run all tests
  - `pnpm test:grammar`: Run tests for tree-sitter-openscad
  - `pnpm test:parser`: Run tests for openscad-parser
  - `pnpm test:watch`: Run tests in watch mode
  - `pnpm test:coverage`: Run tests with coverage

- **Development Commands**:
  - `pnpm dev`: Run all packages in development mode
  - `pnpm dev:parser`: Run openscad-parser in development mode
  - `pnpm graph`: Visualize the dependency graph
  - `pnpm parse`: Parse an OpenSCAD file
  - `pnpm playground`: Open the Tree-sitter playground

- **Maintenance Commands**:
  - `pnpm lint`: Run linting on all packages
  - `pnpm lint:fix`: Fix linting issues
  - `pnpm typecheck`: Run TypeScript type checking
  - `pnpm clean`: Clean all dependencies
  - `pnpm reset`: Reset and reinstall dependencies

### Package-Specific Scripts

#### tree-sitter-openscad

- `nx build tree-sitter-openscad`: Build the grammar and generate the parser
- `nx test tree-sitter-openscad`: Run the grammar tests
- `nx parse tree-sitter-openscad`: Parse an OpenSCAD file
- `nx playground tree-sitter-openscad`: Open the Tree-sitter playground

#### openscad-parser

- `nx build openscad-parser`: Build the parser package
- `nx test openscad-parser`: Run the parser tests
- `nx dev openscad-parser`: Run the parser in development mode

## Coding Best Practices

### General Principles

- **Single Responsibility Principle**: Each module should have a single responsibility
- **DRY (Don't Repeat Yourself)**: Avoid code duplication
- **KISS (Keep It Simple, Stupid)**: Prefer simple solutions over complex ones
- **YAGNI (You Aren't Gonna Need It)**: Don't implement features until needed

### TypeScript Best Practices

- **Type Safety**: Use strict type checking
- **Interfaces**: Define clear interfaces for public APIs
- **Immutability**: Prefer immutable data structures
- **Error Handling**: Handle errors gracefully with specific error types

### Tree-sitter Grammar Best Practices

- **Rule Clarity**: Write clear and readable grammar rules
- **Testing**: Test each rule with various syntax examples
- **Documentation**: Document grammar rules with examples
- **Conflict Resolution**: Resolve conflicts with precedence rules

## Documentation Best Practices

### Code Documentation

- **JSDoc Comments**: Document all public APIs with JSDoc
- **Examples**: Include usage examples in documentation
- **Type Definitions**: Document complex types
- **Error Documentation**: Document error cases and handling

### Project Documentation

- **README**: Clear project overview, installation instructions, and usage examples
- **Architecture Documentation**: Document project structure and design decisions
- **CONTRIBUTING**: Guidelines for contributors
- **CHANGELOG**: Record of changes by version

## Mandatory Workflows

### Feature Development Workflow
1. **Plan Feature**: Define requirements and scope
2. **Write Tests**: Create comprehensive test suite
3. **Implement Feature**: Follow TDD approach
4. **Run Package Tests**: Test the specific package
5. **Run Monorepo Tests**: Run package-specific test commands
6. **Check Dependencies**: Ensure your changes don't break dependent packages
7. **Update Documentation**: Update relevant documentation
8. **Commit**: Include all related changes in a single commit

### Refactoring Workflow
1. **Identify Need**: Code smells, performance issues, technical debt
2. **Write Tests**: Ensure adequate coverage before changes
3. **Establish Baseline**: Verify all tests pass initially
4. **Make Small Changes**: Focus on one improvement at a time
5. **Run Tests**: Verify changes don't break functionality
6. **Document**: Update documentation to reflect changes
7. **Commit**: Use "REFACTOR:" prefix in commit message

### Documentation Workflow
1. **Identify Need**: New code, unclear docs, missing examples
2. **Update JSDoc**: Add/update comments with examples
3. **Update Module Docs**: Document purpose and architecture
4. **Commit**: Use "DOCS:" prefix in commit message

### Debugging Workflow
1. **Reproduce Issue**: Create reliable reproduction steps
2. **Isolate Problem**: Narrow down problematic code
3. **Analyze Root Cause**: Determine why issue occurs
4. **Create Failing Test**: Write test that reproduces issue
5. **Fix Issue**: Implement minimal fix following TDD
6. **Verify Fix**: Confirm test passes and issue is resolved
7. **Document**: Explain issue and solution
8. **Commit**: Use "FIX:" prefix in commit message

### Tree-Sitter Grammar Debugging Workflow
1. **Identify Syntax Issue**: Find problematic OpenSCAD syntax
2. **Create Test Case**: Add a minimal example to the test corpus
3. **Run Grammar Tests**: Use `pnpm test:grammar` to verify failure
4. **Analyze Grammar**: Review grammar.js rules related to the issue
5. **Modify Grammar**: Update grammar.js to handle the syntax correctly
6. **Generate Parser**: Run `pnpm build:grammar` to rebuild the parser
7. **Test Changes**: Run `pnpm test:grammar` to verify fix
8. **Visualize Parse Tree**: Use `pnpm parse examples/test-case.scad` to inspect
9. **Document Changes**: Update grammar documentation

## Project Context

This project aims to create a robust parser for OpenSCAD files using Tree-sitter, enabling rich analysis and manipulation of OpenSCAD code.

### Current Focus

- **Recent Accomplishment**: Implemented FunctionCallVisitor for handling function calls in expressions.
- **Next Steps**: Implement BinaryExpressionVisitor and UnaryExpressionVisitor to handle binary and unary operations with proper precedence.
- **Current Enhancement**: Improving VariableVisitor to handle more complex variable assignments and mathematical expressions.

## Development Setup

### Prerequisites

- Node.js (latest LTS version)
- PNPM (v10.10.0 or later)
- Git

### Initial Setup

1. **Clone the Repository**:
   ```bash
   git clone https://github.com/user/openscad-tree-sitter.git
   cd openscad-tree-sitter
   ```

2. **Install Dependencies**:
   ```bash
   pnpm install
   ```

3. **Build the Project**:
   ```bash
   pnpm build
   ```

### Development Environment

- Use VSCode or another IDE with good TypeScript support
- Install recommended extensions for linting and formatting
- Configure editor to use project's ESLint and Prettier settings

## Debugging Guide

### Common Issues and Solutions

#### Tree-sitter Grammar Issues

1. **Parsing Conflicts**: Check for conflicts in the grammar.js file with `tree-sitter generate --debug`
2. **Node Types**: Ensure node types are correctly defined and used consistently
3. **Rule Precedence**: Check precedence rules for operators and expressions

#### Parser Issues

1. **Type Errors**: Ensure proper typing for all functions and variables
2. **AST Structure**: Validate AST structure matches expected output
3. **Error Handling**: Check for proper error handling and messages

### Debugging Tools

1. **Tree-sitter Playground**: Visualize parse trees for debugging grammar issues
2. **VSCode Debugger**: Use breakpoints and watch expressions for TypeScript debugging
3. **Vitest UI**: Use the Vitest UI for interactive test debugging with `pnpm test:ui`

### Performance Optimization

1. **Profiling**: Use Node.js profiling tools to identify bottlenecks
2. **Memoization**: Use memoization for expensive operations
3. **Lazy Evaluation**: Implement lazy evaluation where appropriate
