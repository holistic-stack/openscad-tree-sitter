/**
 * @file OpenSCAD grammar for tree-sitter
 * @license MIT
 */

module.exports = grammar({
  name: 'openscad',

  word: $ => $.identifier,

  extras: $ => [
    /\s/,
    $.comment,
    $.error_sentinel, // Add error sentinel for better recovery
  ],

  conflicts: $ => [
    [$.module_instantiation, $.primary_expression],
    [$.statement, $.if_statement],
    [$.modifier, $.unary_expression],
    [$.module_instantiation, $.accessor_expression],
    [$.for_header, $.array_literal],
    [$.if_statement],
    [$.list_comprehension_for, $.list_comprehension_for_block],
    [$.list_comprehension_if, $.list_comprehension_if_block],
    [$.array_literal, $.list_comprehension],
    [$.primary_expression, $.accessor_expression],
    [$.accessor_expression, $.primary_expression],
    [$.let_expression, $.expression],
  ],

  rules: {
    source_file: $ => repeat($.statement),

    comment: $ => choice(
      seq('//', /.*/, /\r?\n/),
      seq('/*', /([^*]|\*[^\/])*\*\//)
    ),

    // Error sentinel for better recovery
    error_sentinel: $ => token(prec(-1, /[^\s]+/)),

    // Error recovery helper
    _error_recovery: $ => token(prec(-1, /[^;{}()\[\]\s]+/)),

    statement: $ => choice(
      $.include_statement,
      $.use_statement,
      $.module_definition,
      $.function_definition,
      $.assignment_statement,
      $.module_instantiation,
      $.if_statement,
      $.for_statement,
      $.echo_statement,
      $.assert_statement,
      seq($.expression, optional(';')) // Make semicolon optional for error recovery
    ),

    include_statement: $ => seq(
      'include',
      $.string,
      optional(';')
    ),

    use_statement: $ => seq(
      'use',
      $.string,
      optional(';')
    ),

    module_definition: $ => seq(
      'module',
      field('name', $.identifier),
      field('parameters', $.parameter_list),
      field('body', $.block)
    ),

    function_definition: $ => seq(
      'function',
      field('name', $.identifier),
      field('parameters', $.parameter_list),
      '=',
      field('value', $.expression),
      optional(';') // Make semicolon optional for error recovery
    ),

    parameter_list: $ => seq(
      '(',
      optional($.parameter_declarations),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;{]/)) // Match semicolon or opening brace
      )
    ),

    parameter_declarations: $ => seq(
      $.parameter_declaration,
      repeat(seq(',', $.parameter_declaration)),
      optional(',')
    ),

    parameter_declaration: $ => choice(
      $.identifier,
      $.special_variable,
      seq($.identifier, '=', $.expression),
      seq($.special_variable, '=', $.expression)
    ),

    assignment_statement: $ => seq(
      field('name', choice($.special_variable, $.identifier)),
      '=',
      field('value', $.expression),
      optional(';') // Make semicolon optional for error recovery
    ),

    block: $ => seq(
      '{',
      repeat($.statement),
      choice(
        '}',
        // Error recovery for missing closing brace
        token.immediate(prec(-1, /[^\s;]/)) // Match any non-whitespace, non-semicolon character
      )
    ),

    module_instantiation: $ => seq(
      optional($.modifier),
      field('name', $.accessor_expression),
      field('arguments', $.argument_list),
      choice(
        optional(';'), // Make semicolon optional for error recovery
        $.block,
        $.module_child
      )
    ),

    argument_list: $ => seq(
      '(',
      optional($.arguments),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;{]/)) // Match semicolon or opening brace
      )
    ),

    arguments: $ => seq(
      $.argument,
      repeat(seq(',', $.argument)),
      optional(',')
    ),

    argument: $ => choice(
      $.expression,
      seq($.special_variable, '=', $.expression),
      seq($.identifier, '=', $.expression)
    ),

    module_child: $ => seq(
      'children',
      optional(seq(
        '(',
        optional($.expression),
        choice(
          ')',
          // Error recovery for missing closing parenthesis
          token.immediate(prec(-1, /[;]/)) // Match semicolon
        )
      )),
      optional(';') // Make semicolon optional for error recovery
    ),

    modifier: $ => choice(
      '#',
      '!',
      '%',
      '*',
    ),

    if_statement: $ => seq(
      'if',
      '(',
      $.expression,
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[{]/)) // Match opening brace
      ),
      choice(
        $.block,
        $.statement
      ),
      optional(seq(
        'else',
        choice(
          $.if_statement,
          $.block,
          $.statement
        )
      ))
    ),

    for_statement: $ => seq(
      'for',
      '(',
      $.for_header,
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[{]/)) // Match opening brace
      ),
      choice(
        $.block,
        $.statement
      )
    ),

    for_header: $ => seq(
      field('iterator', choice($.identifier, $.special_variable)),
      '=',
      choice($.range_expression, $.expression)
    ),

    range_expression: $ => choice(
      seq(
        field('start', $.expression),
        ':',
        field('end', $.expression)
      ),
      seq(
        field('start', $.expression),
        ':',
        field('step', $.expression),
        ':',
        field('end', $.expression)
      )
    ),

    echo_statement: $ => seq(
      'echo',
      '(',
      optional($.arguments),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;]/)) // Match semicolon
      ),
      optional(';') // Make semicolon optional for error recovery
    ),

    assert_statement: $ => seq(
      'assert',
      '(',
      $.expression,
      optional(seq(',', $.expression)),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;]/)) // Match semicolon
      ),
      optional(';') // Make semicolon optional for error recovery
    ),

    expression: $ => $.conditional_expression,

    // Precedence levels (higher number = higher precedence)
    // Conditional: 1, Logical OR: 2, Logical AND: 3, Equality: 4, Relational: 5,
    // Additive: 6, Multiplicative: 7, Exponentiation: 8, Unary: 9, Postfix: 10

    conditional_expression: $ => choice(
      prec.right(1, seq(
        field('condition', $.logical_or_expression),
        '?',
        field('consequence', $.expression), // Recursive call to $.expression for consequence
        ':',
        field('alternative', $.conditional_expression) // Allows right-chaining
      )),
      $.logical_or_expression // Pass to next higher precedence
    ),

    logical_or_expression: $ => choice(
      prec.left(2, seq(
        field('left', $.logical_or_expression),
        '||',
        field('right', $.logical_and_expression)
      )),
      $.logical_and_expression // Pass to next higher precedence
    ),

    logical_and_expression: $ => choice(
      prec.left(3, seq(
        field('left', $.logical_and_expression),
        '&&',
        field('right', $.equality_expression)
      )),
      $.equality_expression // Pass to next higher precedence
    ),

    equality_expression: $ => choice(
      prec.left(4, seq(
        field('left', $.equality_expression),
        field('operator', choice('==', '!=')),
        field('right', $.relational_expression)
      )),
      $.relational_expression // Pass to next higher precedence
    ),

    relational_expression: $ => choice(
      prec.left(5, seq(
        field('left', $.relational_expression),
        field('operator', choice('<', '<=', '>', '>=')),
        field('right', $.additive_expression)
      )),
      $.additive_expression // Pass to next higher precedence
    ),

    additive_expression: $ => choice(
      prec.left(6, seq(
        field('left', $.additive_expression),
        field('operator', choice('+', '-')),
        field('right', $.multiplicative_expression)
      )),
      $.multiplicative_expression // Pass to next higher precedence
    ),

    multiplicative_expression: $ => choice(
      prec.left(7, seq(
        field('left', $.multiplicative_expression),
        field('operator', choice('*', '/', '%')),
        field('right', $.exponentiation_expression)
      )),
      $.exponentiation_expression // Pass to next higher precedence
    ),

    exponentiation_expression: $ => choice(
      prec.right(8, seq(
        field('left', $.unary_expression),
        field('operator', '^'),
        field('right', $.exponentiation_expression)
      )),
      $.unary_expression // Pass to next higher precedence
    ),

    unary_expression: $ => choice(
      prec.right(9, seq(
        field('operator', choice('!', '-')),
        field('operand', $.accessor_expression)
      )),
      $.accessor_expression // Pass to next higher precedence
    ),

    accessor_expression: $ => choice(
      $.primary_expression,
      prec.right(20, seq(
        field('array', $.accessor_expression),
        '[',
        field('index', $.expression),
        choice(
          ']',
          // Error recovery for missing closing bracket
          token.immediate(prec(-1, /[;,){}]/)) // Match semicolon, comma, closing parenthesis, or braces
        )
      )), // Index access (higher precedence for nesting)
      prec.left(10, seq(
        field('object', $.accessor_expression),
        '.',
        field('property', $.identifier)
      )), // Member access
      prec.left(10, seq(
        field('function', $.accessor_expression),
        $.argument_list
      ))  // Call expression
    ),

    primary_expression: $ => choice(
      $.parenthesized_expression,
      $.special_variable,
      $.identifier,
      $.number,
      $.string,
      $.boolean,
      $.undef,
      $.array_literal,
      $.list_comprehension,
      $.object_literal,
      $.let_expression
    ),

    parenthesized_expression: $ => seq(
      '(',
      $.expression,
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,{}\[]/)) // Match semicolon, comma, braces, or opening bracket
      )
    ),

    array_literal: $ => prec(1, choice(
      $.range_expression,
      seq('[',
        optional(commaSep1($.expression)),
        choice(
          ']',
          // Error recovery for missing closing bracket
          token.immediate(prec(-1, /[;,){}]/)) // Match semicolon, comma, closing parenthesis, or braces
        )
      )
    )),

    // List comprehension - [expr for (var=list) if (cond)]
    list_comprehension: $ => prec(2, seq(
      '[',
      choice(
        // Traditional syntax: [expr for (var=list) if (cond)]
        seq(
          field('element', $.expression),
          field('for_clause', $.list_comprehension_for),
          optional(field('if_clause', $.list_comprehension_if))
        ),
        // OpenSCAD syntax: [for (var=list) if (cond) expr]
        seq(
          field('for_clause', $.list_comprehension_for_block),
          optional(field('if_clause', $.list_comprehension_if_block)),
          field('element', $.expression)
        )
      ),
      choice(
        ']',
        // Error recovery for missing closing bracket
        token.immediate(prec(-1, /[;,){}]/)) // Match semicolon, comma, closing parenthesis, or braces
      )
    )),

    // Traditional syntax: for (var=list)
    list_comprehension_for: $ => seq(
      'for',
      '(',
      field('iterator', choice($.identifier, $.special_variable)),
      '=',
      field('range', choice($.range_expression, $.expression)),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,\[\]{}]/)) // Match semicolon, comma, brackets, or braces
      )
    ),

    // Traditional syntax: if (cond)
    list_comprehension_if: $ => seq(
      'if',
      '(',
      field('condition', $.expression),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,\[\]{}]/)) // Match semicolon, comma, brackets, or braces
      )
    ),

    // OpenSCAD syntax: for (var=list)
    list_comprehension_for_block: $ => prec(3, seq(
      'for',
      '(',
      field('iterator', choice($.identifier, $.special_variable)),
      '=',
      field('range', choice($.range_expression, $.expression)),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,\[\]{}]/)) // Match semicolon, comma, brackets, or braces
      )
    )),

    // OpenSCAD syntax: if (cond)
    list_comprehension_if_block: $ => seq(
      'if',
      '(',
      field('condition', $.expression),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,\[\]{}]/)) // Match semicolon, comma, brackets, or braces
      )
    ),

    // Object literals
    object_literal: $ => prec(1, seq(
      '{',
      optional(seq(
        commaSep1($.object_field),
        optional(',')
      )),
      choice(
        '}',
        // Error recovery for missing closing brace
        token.immediate(prec(-1, /[;,)\[]/)) // Match semicolon, comma, closing parenthesis, or opening bracket
      )
    )),

    object_field: $ => seq(
      field('key', $.string),
      ':',
      field('value', $.expression)
    ),

    // Let expression
    let_expression: $ => prec(1, seq(
      'let',
      '(',
      commaSep1($.let_assignment),
      choice(
        ')',
        // Error recovery for missing closing parenthesis
        token.immediate(prec(-1, /[;,{}\[]/)) // Match semicolon, comma, braces, or opening bracket
      ),
      field('body', $.expression)
    )),

    let_assignment: $ => seq(
      field('name', choice($.identifier, $.special_variable)),
      '=',
      field('value', $.expression)
    ),

    range_expression: $ => choice(
      seq('[', $.expression, ':', $.expression, ']'),
      seq('[', $.expression, ':', $.expression, ':', $.expression, ']')
    ),

    special_variable: $ => token(/\$[\p{L}_][\p{L}\p{N}_]*/u),

    string: $ => choice(
      // Double-quoted strings with proper termination
      seq('"', optional(token.immediate(/[^"]*/)), '"'),
      // Single-quoted strings with proper termination
      seq("'", optional(token.immediate(/[^']*/)), "'"),
      // Error recovery for unterminated double-quoted strings
      seq('"', token.immediate(/[^"\n]*/), token.immediate(prec(-1, /$/))),
      // Error recovery for unterminated single-quoted strings
      seq("'", token.immediate(/[^'\n]*/), token.immediate(prec(-1, /$/))),
    ),

    number: $ => {
      const decimal = /-?[0-9]+\.[0-9]+([eE][-+]?[0-9]+)?/;
      const integer = /-?[0-9]+([eE][-+]?[0-9]+)?/;
      return token(choice(
        decimal,
        integer
      ));
    },

    boolean: $ => choice(
      'true',
      'false'
    ),

    undef: $ => 'undef',

    identifier: $ => /[\p{L}_][\p{L}\p{N}_]*/u,
  }
});

function commaSep1(rule) {
  return seq(rule, repeat(seq(',', rule)));
}
